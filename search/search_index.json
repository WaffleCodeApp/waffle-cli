{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Waffle CLI","text":"<p>Waffle helps one deploy a secrure foundation for web applications and host their backend and frontend components using AWS.</p> <p>To deploy a sample application to your AWS account, checkout the Quickstart. To deploy your own project, refer to Get Started.</p>"},{"location":"#what-is-waffle","title":"What is Waffle?","text":"<p>\"Waffle\" is a set of tools that help web-application developers kick off new projects or move existing projects quickly in a secure, scalable, easily reproducible, audit- and pentest-ready cloud environment without requiring devops expertise.</p> <p>Waffle exclusively builds on AWS. It sets up and configures native AWS components in a way that's suitable for regular B2B web-applications. It can also be used for backend/API only solutions too.</p> <p>Waffle help one build a complex cloud infrastructure with losely connected templates that interact with each other. These templates are written for AWS CloudFormation. They deploy AWS components with default values, designed for the purpose.</p> <p>The default settings provided by Waffle can be manually tweaked.  Waffle is open source. Its templates can be altered or completely replaced too if the project that Waffle is used for develops requirements that Waffle doesn't support out of the box. 3rd party CloudFormation templates also perfectly work together with Waffle's templates. </p>"},{"location":"#why-waffle","title":"Why Waffle?","text":"<p>To kick off a B2B web-project it's hard (if possible at all) to meet all the usual requirements without Waffle. These are:</p> <ul> <li>Kicking off the project fast and cheap in small-scale for validation and early-stage growth.</li> <li>Enable a high level of security to earn business partners' trust.</li> <li>Enable scaling.</li> </ul>"},{"location":"#alternatives-to-waffle","title":"Alternatives to Waffle.","text":"<p>There are many:</p> <ul> <li>AWS, Azure: Working with low-level infrastructure-as-services like AWS or Azure require a high level of related expertise. It doesn't only take way too much time to build a suitable cloud infrastructure compared to the webapplication that's being hosted, but you also need to pay for the related engineering. This is approach is suitable if you already have a strong devops and infrastructure team. What you might miss from the goals above: kicking off fast and cheap.</li> <li>AWS SAM: although we can think about it as a simplification-layer for building applicaitons with serverless cloud infrastructure, it still requires significant AWS-specific expertise. And serverless is often not the best choice for a project in the validation-phase. This solution is suitable if you already have engineers with an AWS background and your project best developed for serverless right from the beginning. What you might miss: kicking off fast and cheap.</li> <li>Digital Ocean, Heroku: These platform-as-service solutions provide backend services that are similarly easy to set up as doing it with Waffle. They also provide dashboards and control interfaces that are easy to work with without being an infrastructure expert. These solutions' pricing model is designed for small-scale projects. If your project scales up, then the price likely goes up as well. You'll face a decision if you rewrite your project for an infrastructure that better supports scaling, or accept the higher costs. These services are mostly suitable for teams without deep infrastructure and devops related expertise and without planning to scale significantly up. What you might miss: enabling scaling.</li> <li>Supabase: It's a collection of great 3rd party open source projects that you can host on your own, or leave hosting to Supabase. Projects built with Supabase require very specific implementations to these opensource projects. Scalability is limited to how you can deploy these 3rd party solutions and to these solutions themselves. You should examine these tools before you commit to using them. If they fit, it can be a great choice for you. What you might miss: if deployed to your own premises or AWS private cloud, then security (and scaling) might be a concern.</li> <li>BYO Linux server: While this can be a very fast and cheap way to develop and deploy new applications, implementing CICD pipelines and other devops practices that are required for generic compliance can be more than tricky. This can be suitable option if you have a team of max 1-2 engineers.</li> </ul>"},{"location":"#the-goals-of-waffle","title":"The goals of Waffle","text":"<ul> <li>Leveraging the flexibilityand scalability to AWS, by only relying on AWS native components and solutions.</li> <li>Providing default setup and settings for AWS components to provide high-level, industry-standard security suitable for basic projects, without having to do the research.</li> <li>Providing a simple way of configuring and deploying components by working with pre-built stack-templates that can be deployed with a basic backend-engineer knowledge.</li> <li>No lock-in: only providing solutions that can smoothly work with custom or 3rd party solutions designed for AWS.</li> <li>Open source: the templates and defaults provided by Waffle can be tweaked, changed or completely replaced without major refactoring.</li> <li>Supporting industry-best practices for backend and api development.</li> <li>Logging and monitoring out of the box, compliant with SOC II Type 2.</li> </ul>"},{"location":"#when-not-to-use-waffle","title":"When not to use Waffle?","text":"<p>Working with Waffle will require you to work with the AWS console. Just instead of figuring it out how it works, things will be set up for you by Waffle. If you don't think you'll project will ever require the components, security and scalability provided by AWS, then Waffle might be an overkill for you.</p>"},{"location":"quickstart/","title":"Waffle CLI Quickstart","text":"<p>The Waffle CLI keeps track of every deployment created with it in a local config file. Creating a deployment means that a settings file is created, and AWS components are created based on the settings using CloudFormation. It's possible to change the settings later on, the Waffle CLI can invoke AWS CloudFormation to update the existing AWS components accordingly.</p> <p>The idea is that the settings files should be added to a repository. It can be either an isolated repo, or part of a monolith repo that holds the rest of the project.</p>"},{"location":"quickstart/#installing-the-waffle-cli","title":"Installing the Waffle CLI","text":"<pre><code>pip install waffle-cli\n</code></pre>"},{"location":"quickstart/#creating-a-settings-file","title":"Creating a settings file","text":"<p>First create the settings file locally. The settings file will be created in the current <code>.waffle</code> folder: it's going to be a <code>.json</code> file with the chosen deployment id.</p> <p>For the choice of <code>deployment id</code> check out the terminology above for detailed explanation. Here well use <code>dev</code> in the examples below.</p> <pre><code>waffle create_deployment_settings dev\n</code></pre>"},{"location":"quickstart/#setting-up-a-local-aws-profile","title":"Setting up a local AWS profile","text":"<pre><code>waffle configure_aws_profile dev\n</code></pre>"},{"location":"quickstart/#deploying-dns-settings-and-ssl-certification","title":"Deploying DNS settings and SSL certification","text":"<pre><code>waffle configure_deployment_domain dev dev.example.com\n</code></pre> <pre><code>waffle create_deployment_certificate dev\n</code></pre>"},{"location":"quickstart/#deploying-foundational-stacks","title":"Deploying foundational stacks","text":"<pre><code>waffle deploy_vpc dev\n</code></pre> <pre><code>waffle deploy_auth dev\n</code></pre> <pre><code>waffle deploy_api dev\n</code></pre> <pre><code>waffle deploy_alerts dev\n</code></pre> <pre><code>waffle deploy_github dev\n</code></pre> <pre><code>waffle deploy_deployment dev\n</code></pre>"},{"location":"terminology/","title":"Waffle Terminology","text":""},{"location":"terminology/#deployment","title":"Deployment","text":""},{"location":"terminology/#deployment-id","title":"Deployment ID","text":""},{"location":"terminology/#local-aws-profile","title":"Local AWS profile","text":""},{"location":"terminology/#stack-or-cloudformation-stack","title":"Stack or Cloudformation Stack","text":""},{"location":"get_started/","title":"Get Started","text":""},{"location":"reference/create_deployment_settings/","title":"create_deployment_settings","text":"<p>Creates a new set of settings. This command only creates a settings file locally. Adding different features to it, and actually deploying it to AWS is done by other commands.</p> <p>Usage:</p> <pre><code>waffle create_deployment_settings DEPLOYMENT_ID DEPLOYMENT_TYPE\n</code></pre> <p>Where:</p> <ul> <li> <p><code>DEPLOYMENT_ID</code> The deployment id refers to a deployment. The idea is to use waffle in a repository, this case it's a common practice to use the SDLC phase's name that the deployment is used for. It could be for example something like <code>dev</code>, <code>development</code>, <code>qa</code>, <code>prod</code>.</p> </li> <li> <p><code>DEPLOYMENT_TYPE</code> There are two deployment types supported: <code>DEV</code> and <code>PROD</code>. This setting influences how logging and monitoring is done in AWS. In general in case of <code>DEV</code> CloudWatch logs are only retained for a month, and only the most crucial CloudWatch Alarms are set. While in case of <code>PROD</code>, the log retention is 365 days, and all alarms are set up that are required for an SOC II Type 2 audit.</p> </li> </ul>"},{"location":"reference/deployment_settings_file/","title":"Waffle CLI Deployment Settings","text":"<p>The settings files are stored in the <code>.waffle</code> folder. Each deployment has its own settings file, with the filename <code>DEPLOYMENT_ID.json</code> (like for example <code>dev.json</code>).</p>"}]}